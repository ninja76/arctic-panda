def local_transform(rectascension,declination,grad_per_cm)
  m_PI = 3.141592653589793
  m_PI_2 = m_PI / 2
  phi= -(rectascension+12)*15*m_PI/180.0;
  delta= declination*m_PI/180.0;
  alpha= -delta+m_PI_2;
  rad_per_cm= grad_per_cm*m_PI/180.0;
  a_unscaled00= Math.sin(phi);
  a_unscaled01= Math.cos(phi);
  a_unscaled02= 0.0;
  a_unscaled10= Math.cos(phi)*Math.cos(alpha);
  a_unscaled11= -Math.sin(phi)*Math.cos(alpha);
  a_unscaled12= Math.sin(alpha);
  a_unscaled20= -Math.cos(phi)*Math.sin(alpha);
  a_unscaled21= Math.sin(phi)*Math.sin(alpha);
  a_unscaled22= Math.cos(alpha);
  a_00 = a_unscaled00 /rad_per_cm
  a_01 = a_unscaled01 /rad_per_cm
  a_02 = a_unscaled02 /rad_per_cm
  a_10 = a_unscaled10 /rad_per_cm
  a_11 = a_unscaled11 /rad_per_cm
  a_12 = a_unscaled12 /rad_per_cm
  a_20 = a_unscaled20 /rad_per_cm
  a_21 = a_unscaled21 /rad_per_cm
  a_22 = a_unscaled22 /rad_per_cm
  return a_unscaled20,a_unscaled21,a_unscaled22,a_00,a_01,a_02,a_10,a_11,a_12,a_20,a_21,a_22
end


def buildMapData (objects, zoom)
  zoom = zoom.to_i 
  output = []
  imageH = 600
  imageW = 1200
  width =  800 
  height = 800
  avgX = 0
  avgY = 0
  centerX = -0 
  centerY = -0 
  m_PI = 3.141592653589793
  m_PI_2 = m_PI / 2 
  puts "#{zoom}"
  rectascension = 5.5 
  declination = 0
  grad_per_cm = 0.05
  phi= -(rectascension+12)*15*m_PI/180.0;
  delta= declination*m_PI/180.0;
  alpha= -delta+m_PI_2;
  rad_per_cm= grad_per_cm*m_PI/180.0;
  a_unscaled00= Math.sin(phi);
  a_unscaled01= Math.cos(phi);
  a_unscaled02= 0.0;
  a_unscaled10= Math.cos(phi)*Math.cos(alpha);
  a_unscaled11= -Math.sin(phi)*Math.cos(alpha);
  a_unscaled12= Math.sin(alpha);
  a_unscaled20= -Math.cos(phi)*Math.sin(alpha);
  a_unscaled21= Math.sin(phi)*Math.sin(alpha);
  a_unscaled22= Math.cos(alpha);
  a_00 = a_unscaled00 /rad_per_cm
  a_01 = a_unscaled01 /rad_per_cm
  a_02 = a_unscaled02 /rad_per_cm
  a_10 = a_unscaled10 /rad_per_cm
  a_11 = a_unscaled11 /rad_per_cm
  a_12 = a_unscaled12 /rad_per_cm
  a_20 = a_unscaled20 /rad_per_cm
  a_21 = a_unscaled21 /rad_per_cm
  a_22 = a_unscaled22 /rad_per_cm
  objects = objects.to_a
   objects.each do |key|
     ra = key[:ra]
     dec = key[:dec]
     phi= ra*15*m_PI/180.0;
     delta= dec*m_PI/180.0;
     cos_delta= Math.cos(delta);

     x0= cos_delta*Math.cos(phi);
     y0= cos_delta*Math.sin(phi);
     z0= Math.sin(delta);

     z1= a_unscaled20*x0+a_unscaled21*y0+a_unscaled22*z0;
     #if(z1<-DBL_EPSILON)return false;
     zt= 1.0-z1           
     stretch= 1.0+zt*
     (1.0/3.0+zt*
     (2.0/15.0+zt*
     (2.0/35.0+zt*
     (8.0/315.0+zt*
     (8.0/693.0))))) 
     x1= a_00*x0+a_01*y0;
     y1= a_10*x0+a_11*y0+a_12*z0;
     x= x1*stretch+width/2.0;
     y= -y1*stretch+height/2.0;

     sX = key[:cX]
     sY = key[:cY]
     m  = key[:mag].to_f
     b  = key[:bayer]
     n  = key[:name]
     #if sY > 3.141592
     #  sY -= 2 * 3.141592
     #end
     orgx = 0.5 * imageH
     orgy = 0.5 * imageW
     screenX = orgx + (sX - centerX) / zoom
     screenY = orgy + (sY - centerY) / -zoom
     screenX = (imageW / 2) - ((imageW / (2 * zoom))) * (sY-centerY);
     screenY = (imageH / 2) - ((imageH / (2 * zoom))) * (sX-centerX);
     #screenX = screenX + 4 *((key[:cZ] - 0) / zoom)
     screenY = screenY
     label = ""
     label = n
     output  << {:x => x, :y => y, :mag => m, :label => label} 
   end
     map_coords = output.to_json
end
